<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Microservices Architecture Scene</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@5.0.0/dist/aframe-event-set-component.min.js"></script>
    <script>
      AFRAME.registerComponent('start-button', {
  init: function () {
    this.el.addEventListener('click', function () {
      this.emit('start-data-flow');
    });
  }
});
      AFRAME.registerComponent('pause-button', {
  init: function () {
    this.el.addEventListener('click', function () {
      var vis = document.querySelector('[microservices-visualization]').components['microservices-visualization'];
      vis.isPaused = !vis.isPaused;
      this.setAttribute('text', 'value', vis.isPaused ? 'Resume' : 'Pause');
      if (!vis.isPaused) vis.animateNextStep();
    });
  }
});
      AFRAME.registerComponent('article-content', {
        init: function () {
          this.sections = [
             {
        title: "Introduction to Microservices Architecture with Docker and Kubernetes",
        content: "In the rapidly evolving landscape of software development and deployment, microservices architecture has emerged as a powerful paradigm for building scalable, maintainable, and resilient applications. This architectural approach, coupled with containerization technologies like Docker and orchestration platforms such as Kubernetes, has revolutionized the way we design, develop, and deploy modern applications. In this comprehensive guide, we'll delve into the world of microservices architecture, explore the role of Docker in containerization, and understand how Kubernetes orchestrates these containers to create robust, scalable systems."
      },
      {
        title: "Understanding Microservices Architecture",
        content: "Microservices architecture is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.\n\nKey characteristics of microservices include:\n1. Modularity: Each service is focused on a specific business capability.\n2. Independence: Services can be developed, deployed, and scaled independently.\n3. Technological diversity: Different services can use different technologies and programming languages.\n4. Resilience: Failure in one service doesn't necessarily affect the entire application.\n5. Scalability: Individual services can be scaled based on demand."
      },
      {
        title: "The Role of Docker in Microservices",
        content: "Docker plays a crucial role in implementing microservices architecture by providing containerization. Containers are lightweight, standalone, executable packages of software that include everything needed to run an application: code, runtime, system tools, system libraries, and settings.\n\nKey benefits of using Docker for microservices:\n1. Consistency: Ensures that the application runs the same in any environment.\n2. Isolation: Containers are isolated from each other and the host system.\n3. Portability: Containers can run on any system that supports Docker.\n4. Efficiency: Containers share the host OS kernel, making them more lightweight than virtual machines.\n5. Rapid deployment: Containers can be started and stopped quickly."
      },
      {
        title: "Kubernetes: Orchestrating Microservices",
        content: "While Docker solves the problem of containerization, Kubernetes addresses the challenge of orchestrating these containers at scale. Kubernetes, often abbreviated as K8s, is an open-source platform designed to automate deploying, scaling, and operating application containers.\n\nKey features of Kubernetes:\n1. Auto-scaling: Automatically adjusts the number of containers based on CPU utilization or other application-provided metrics.\n2. Self-healing: Restarts containers that fail, replaces and reschedules containers when nodes die.\n3. Service discovery and load balancing: Kubernetes can expose a container using the DNS name or using their own IP address.\n4. Automated rollouts and rollbacks: Kubernetes progressively rolls out changes to your application or its configuration, while monitoring application health to ensure it doesn't kill all your instances at the same time.\n5. Secret and configuration management: Kubernetes lets you store and manage sensitive information, such as passwords, OAuth tokens, and SSH keys."
      },
      {
        title: "Implementing Microservices with Docker and Kubernetes",
        content: "Implementing a microservices architecture with Docker and Kubernetes involves several steps:\n\n1. Design your microservices: Break down your application into smaller, independent services.\n2. Containerize your services: Create Docker images for each of your microservices.\n3. Create Kubernetes deployments: Define how your containerized applications should run in Kubernetes clusters.\n4. Set up services and ingress: Define how your microservices communicate with each other and the outside world.\n5. Configure persistence: Set up persistent storage for your stateful services.\n6. Implement monitoring and logging: Use Kubernetes' built-in tools or third-party solutions to monitor your microservices.\n7. Implement CI/CD: Set up continuous integration and deployment pipelines to automate the process of building, testing, and deploying your microservices."
      },
      {
        title: "Challenges and Best Practices",
        content: "While microservices offer many benefits, they also come with their own set of challenges:\n\n1. Increased complexity: Managing multiple services can be more complex than a monolithic application.\n2. Data consistency: Ensuring data consistency across services can be challenging.\n3. Testing: Testing the entire system can be more complex with microservices.\n4. Monitoring: Monitoring and troubleshooting can be more difficult with distributed systems.\n\nBest practices to address these challenges:\n1. Use API gateways to manage communication between services.\n2. Implement robust logging and monitoring solutions.\n3. Use circuit breakers to prevent cascading failures.\n4. Implement proper service discovery mechanisms.\n5. Use container orchestration tools like Kubernetes to manage complexity.\n6. Implement proper security measures at both the container and network level."
      },
      {
        title: "Conclusion",
        content: "Microservices architecture, when implemented with Docker and Kubernetes, provides a powerful approach to building scalable, resilient, and maintainable applications. Docker enables consistent and portable deployment of services, while Kubernetes provides robust orchestration capabilities to manage these services at scale.\n\nWhile this approach comes with its own set of challenges, the benefits often outweigh the complexities for many organizations, especially those dealing with large-scale, complex applications. As with any architectural decision, it's important to carefully consider your specific needs and constraints when deciding whether to adopt a microservices approach.\n\nAs the field continues to evolve, we can expect to see even more tools and best practices emerge to support microservices architectures, further cementing their place in the modern software development landscape."
      }
          ];
          this.currentSection = 0;
          this.createContent();
          this.createNavButtons();
        },

        createContent: function () {
    const contentEntity = document.createElement('a-entity');
    contentEntity.setAttribute('geometry', 'primitive: plane; width: 6; height: 4');
    contentEntity.setAttribute('material', 'color: #000; opacity: 1');
    contentEntity.setAttribute('position', '-1 1.5 -2'); // Moved closer and to the left

    this.titleText = document.createElement('a-text');
    this.titleText.setAttribute('color', '#FFF');
    this.titleText.setAttribute('align', 'center');
    this.titleText.setAttribute('position', '0 1.6 0.01'); // Position remains the same
    this.titleText.setAttribute('scale', '1.0 1.0 1.0'); // Title size
    this.titleText.setAttribute('width', '5');

    this.contentText = document.createElement('a-text');
    this.contentText.setAttribute('color', '#FFF');
    this.contentText.setAttribute('position', '-2.5 0.2 0.01'); // Adjusted to fit within the plane
    this.contentText.setAttribute('width', '5.5');
    this.contentText.setAttribute('height', '3.2');
    this.contentText.setAttribute('wrap-count', '60'); // Adjust for better fit
    this.contentText.setAttribute('scroll', 'enabled: true');
    this.contentText.setAttribute('anchor', 'left');
    this.contentText.setAttribute('scale', '1.2 1.2 1.2'); // Content size

    contentEntity.appendChild(this.titleText);
    contentEntity.appendChild(this.contentText);
    
    // Append the content entity to the main entity
    this.el.appendChild(contentEntity);
    
    // Call updateContent to set initial text
    this.updateContent();
  },

  createNavButtons: function () {
    const prevButton = document.createElement('a-entity');
    prevButton.setAttribute('geometry', 'primitive: plane; width: 0.6; height: 0.3');
    prevButton.setAttribute('material', 'color: #4CAF50');
    prevButton.setAttribute('position', '-0.7 0.2 0.1'); // Moved down by 1 unit
    prevButton.setAttribute('text', 'value: Prev; align: center; color: white');
    prevButton.addEventListener('click', () => this.navigate(-1));

    const nextButton = document.createElement('a-entity');
    nextButton.setAttribute('geometry', 'primitive: plane; width: 0.6; height: 0.3');
    nextButton.setAttribute('material', 'color: #4CAF50');
    nextButton.setAttribute('position', '0.7 0.2 0.1'); // Moved down by 1 unit
    nextButton.setAttribute('text', 'value: Next; align: center; color: white');
    nextButton.addEventListener('click', () => this.navigate(1));

    this.el.appendChild(prevButton);
    this.el.appendChild(nextButton);
  },


  navigate: function (direction) {
    this.currentSection += direction;
    if (this.currentSection < 0) this.currentSection = 0;
    if (this.currentSection >= this.sections.length) this.currentSection = this.sections.length - 1;
    this.updateContent();
    this.el.emit('sectionchange', { section: this.currentSection });
  },

  updateContent: function () {
    const section = this.sections[this.currentSection];
    this.titleText.setAttribute('value', section.title);
    this.contentText.setAttribute('value', section.content);
  }
});

     AFRAME.registerComponent('microservices-visualization', {
  init: function () {
 this.services = {
  client:         { el: null, position: '-1.5 2 0' },
  apiGateway:     { el: null, position: '0 2 0' },
  authService:    { el: null, position: '1.5 3 0' },
  userService:    { el: null, position: '1.5 2 0' },
  productService: { el: null, position: '1.5 1 0' },
  orderService:   { el: null, position: '3 2 0' },
  paymentService: { el: null, position: '4.5 2 0' }
};

    // Create and position service entities
    for (let [serviceName, serviceData] of Object.entries(this.services)) {
      let serviceEl = document.createElement('a-box');
      serviceEl.setAttribute('id', serviceName);
      serviceEl.setAttribute('color', this.getServiceColor(serviceName));
      serviceEl.setAttribute('position', serviceData.position);
      serviceEl.setAttribute('scale', '0.5 0.5 0.5');
      this.el.appendChild(serviceEl);
      serviceData.el = serviceEl;
    }

    this.dataFlow = [
      { from: 'client', to: 'apiGateway', data: { action: "place_order", user_id: "12345", product_id: "67890", quantity: 2 } },
      { from: 'apiGateway', to: 'authService', data: { action: "authenticate", user_id: "12345", auth_token: "abcdef" } },
      { from: 'authService', to: 'apiGateway', data: { user_id: "12345", authenticated: true } },
      { from: 'apiGateway', to: 'userService', data: { action: "get_user_info", user_id: "12345" } },
      { from: 'userService', to: 'apiGateway', data: { user_id: "12345", address: "123 Main St", preferred_payment: "credit_card" } },
      { from: 'apiGateway', to: 'productService', data: { action: "check_product_availability", product_id: "67890", quantity: 2 } },
      { from: 'productService', to: 'apiGateway', data: { product_id: "67890", available: true, stock: 10 } },
      { from: 'apiGateway', to: 'orderService', data: { action: "create_order", user_id: "12345", product_id: "67890", quantity: 2, address: "123 Main St", payment: "credit_card" } },
      { from: 'orderService', to: 'apiGateway', data: { order_id: "A123", status: "pending_payment" } },
      { from: 'orderService', to: 'paymentService', data: { action: "process_payment", order_id: "A123", amount: 100.00, payment_method: "credit_card" } },
      { from: 'paymentService', to: 'orderService', data: { payment_status: "success", transaction_id: "TXN789" } },
      { from: 'orderService', to: 'apiGateway', data: { order_id: "A123", status: "completed" } },
      { from: 'apiGateway', to: 'client', data: { order_id: "A123", status: "completed", message: "Your order has been successfully placed!" } }
    ];

    this.currentStep = 0;
    this.isPaused = false;

    this.el.sceneEl.addEventListener('start-data-flow', this.startDataFlow.bind(this));

    // Adjust the position and rotation of the entire visualization
    this.el.setAttribute('position', '3 0.4 -3'); // Move to the right
    this.el.setAttribute('rotation', '0 -30 0');  // Rotate slightly towards the camera
  },

  getServiceColor: function(serviceName) {
    const colors = {
      client: '#FF5733',
      apiGateway: '#33FF57',
      authService: '#3357FF',
      userService: '#FF33F1',
      productService: '#33FFF1',
      orderService: '#F1FF33',
      paymentService: '#FF3333'
    };
    return colors[serviceName] || '#CCCCCC';
  },

  startDataFlow: function () {
    this.animateNextStep();
  },

  animateNextStep: function () {
    if (this.isPaused || this.currentStep >= this.dataFlow.length) return;

    var step = this.dataFlow[this.currentStep];
    var fromEl = this.services[step.from].el;
    var toEl = this.services[step.to].el;

    // Create a visual representation of data (e.g., a small sphere)
    var dataEl = document.createElement('a-sphere');
    dataEl.setAttribute('radius', '0.1');
    dataEl.setAttribute('color', 'yellow');
    dataEl.setAttribute('position', fromEl.getAttribute('position'));

    // Animate the data from the 'from' service to the 'to' service
    dataEl.setAttribute('animation', {
      property: 'position',
      to: toEl.getAttribute('position'),
      dur: 2000,
      easing: 'linear'
    });

    this.el.appendChild(dataEl);

    // Remove the data element after animation completes
    setTimeout(() => {
      this.el.removeChild(dataEl);
      this.currentStep++;
      this.animateNextStep();
    }, 2000);

    // Update the info panel with the current step's data
    this.updateInfoPanel(step.data);
  },

  updateInfoPanel: function (data) {
    // Update an info panel entity with the current data
    var infoPanel = document.querySelector('#infoPanel');
    infoPanel.setAttribute('text', {
      value: JSON.stringify(data, null, 2),
      width: 2
    });
  },

  pause: function () {
    this.isPaused = true;
  },

  resume: function () {
    this.isPaused = false;
    this.animateNextStep();
  },

  reset: function () {
    this.currentStep = 0;
    this.isPaused = false;
    var infoPanel = document.querySelector('#infoPanel');
    infoPanel.setAttribute('text', {
      value: 'Data flow reset. Click Start to begin.',
      width: 2
    });
  }
});
    </script>
  </head>
  <body>
    <a-scene>
      <a-assets>
        <img id="sky" crossorigin="anonymous" src="https://cdn.glitch.global/5cfc02c2-e08f-4e29-9383-05c3fa57335f/Microservice%20Skybox.png?v=1729023719252">
      </a-assets>

      <!-- Environment -->
      <a-sky src="#sky"></a-sky>
      
      <!-- Article Content -->
       <a-entity position="0 1.6 -3" rotation="0 0 0" article-content></a-entity>
     
      <!-- Microservices Visualization -->
     <a-entity position="4 1.6 -4" rotation="0 -45 0" microservices-visualization>
        <!-- Client -->
        <a-box position="0 2.15 0.25" depth="1.2" height="0.4" width="0.6" color="red" rotation="15 -30 15" service-interaction="name: client"></a-box>
        <a-text value="Client" position="0 2.3 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <!-- API Gateway -->
        <a-box position="0 1.15 0.25" depth="1.2" height="0.4" width="0.6" color="blue" rotation="15 -30 15" service-interaction="name: api-gateway"></a-box>
        <a-text value="API Gateway" position="0 1.3 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <!-- Services Row -->
        <a-box position="-1.5 0.15 0.25" depth="1.2" height="0.4" width="0.6" color="green" rotation="15 -30 15" service-interaction="name: auth-service"></a-box>
        <a-text value="Auth Service" position="-1.5 0.3 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <a-box position="-0.5 0.15 0.25" depth="1.2" height="0.4" width="0.6" color="yellow" rotation="15 -30 15" service-interaction="name: user-service"></a-box>
        <a-text value="User Service" position="-0.5 0.3 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <a-box position="0.5 0.15 0.25" depth="1.2" height="0.4" width="0.6" color="purple" rotation="15 -30 15" service-interaction="name: product-service"></a-box>
        <a-text value="Product Service" position="0.5 0.3 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <a-box position="1.5 0.15 0.25" depth="1.2" height="0.4" width="0.6" color="orange" rotation="15 -30 15" service-interaction="name: order-service"></a-box>
        <a-text value="Order Service" position="1.5 0.3 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <!-- Payment Services -->
        <a-box position="1 -0.85 0.25" depth="1.2" height="0.4" width="0.6" color="pink" rotation="15 -30 15" service-interaction="name: payment-service"></a-box>
        <a-text value="Payment Service" position="1 -0.7 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <a-box position="2 -0.85 0.25" depth="1.2" height="0.4" width="0.6" color="cyan" rotation="15 -30 15" service-interaction="name: external-payment"></a-box>
        <a-text value="External Payment" position="2 -0.7 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <!-- Databases -->
        <a-cylinder position="-0.5 -1 0" radius="0.25" height="0.5" color="lightgray" service-interaction="name: user-db"></a-cylinder>
        <a-text value="User DB" position="-0.5 -0.7 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <a-cylinder position="-1.5 -1 0" radius="0.25" height="0.5" color="lightgray" service-interaction="name: product-db"></a-cylinder>
        <a-text value="Product DB" position="-1.5 -0.7 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
        <a-cylinder position="-2.5 -1 0" radius="0.25" height="0.5" color="lightgray" service-interaction="name: order-db"></a-cylinder>
        <a-text value="Order DB" position="-2.5 -0.7 0.5" align="center" rotation="-15 30 0" scale="0.5 0.5 0.5"></a-text>
      </a-entity>

  <!-- Start Button (outside of control panel) -->
<a-entity id="startButton" 
    geometry="primitive: plane; width: 1; height: 0.5"
    material="color: green"
    position="-1 0 -3"
    text="value: Start Data Flow; align: center; width: 4"
    start-button>
</a-entity>

<a-entity id="controlPanel" position="3.5 2.2 -3.5" rotation="0 -45 0">
  <a-entity id="startButtonInPanel" 
            geometry="primitive: plane; width: 0.8; height: 0.4; depth: 0.05"
            material="color: green"
            position="0 0.2 0"
            text="value: Start; align: center; width: 2; wrapCount: 20"
            start-button>
  </a-entity>
  
  <a-entity id="pauseButton" 
            geometry="primitive: plane; width: 0.6; height: 0.3"
            material="color: orange"
            position="0 -0.2 0"
            text="value: Pause; align: center; width: 2"
            pause-button>
  </a-entity>
</a-entity>

<!-- Info Panel (outside of control panel) -->
<a-entity id="infoPanel"
      geometry="primitive: plane; width: 2; height: 1.5; depth: 0.05"
      material="color: white"
      position="3.5 -1 -3.5"
      rotation="0 -45 0"
      text="value: Data will appear here; width: 1.4; color: black; align: left">
</a-entity>

<!-- Camera and Cursor -->
<a-camera position="0 1.6 0" rotation="0 0 0">
  <a-cursor></a-cursor>
</a-camera>
    </a-scene>
  </body>
</html>
